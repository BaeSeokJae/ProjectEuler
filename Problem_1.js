const fs = require('fs');
/**
1000보다 작은 자연수 중에서 3 또는 5의 배수를 모두 더하면?
10보다 작은 자연수 중에서 3 또는 5의 배수는 3, 5, 6, 9 이고, 이것을 모두 더하면 23입니다.
1000보다 작은 자연수 중에서 3 또는 5의 배수를 모두 더하면 얼마일까요?
 */
function problem1(arg) {
  let sum = 0;
  for (let i = 0; i < arg; i++)
    if (i % 3 === 0 || i % 5 === 0) {
      sum = sum + i;
    }
  return sum;
}
/**
피보나치 수열에서 4백만 이하이면서 짝수인 항의 합

피보나치(Fibonacci) 수열의 각 항은 바로 앞의 항 두 개를 더한 것입니다. 1과 2로 시작하는 경우 이 수열은 아래와 같습니다.

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

4백만 이하의 짝수 값을 갖는 모든 피보나치 항을 더하면 얼마가 됩니까?

풀이

피보나치(Fibonacci) 수열의 각 항은 바로 앞의 항 두 개를 더한 것입니다.

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

따라서

1 + 2 = 3
2 + 3 = 5
3 + 5 = 8
5 + 8 = 13
...

위와 같은 방식으로 진행하기 때문에
초기 fibo_1, fibo_2값을 정한후 합계(fibo_3)를 내고
짝수면 결과값 + 합계(fibo_3) / 홀수면 넘긴 후
fibo_1값은 fibo_2로 치환
fibo_2값은 fibo_3으로 치환하는 방식으로 4백만 이하값을 반복문 실행
 */
function problem2(arg) {
  // 재귀함수 사용 실패
  //   let sum = 0;
  //   fibonacci = (arg) => {
  //     if (arg < 2) return arg;
  //     return fibonacci(arg - 1) + fibonacci(arg - 2);
  //   };

  //   for (let i = 1; i < arg; i++) {
  //     if (fibonacci(i) % 2 === 0) {
  // console.log("결과" + fibonacci(i));
  // sum = sum + fibonacci(i);
  //     }
  //   }
  //   return sum;
  //*

  let sum = 2;
  let fibo_1 = 1;
  let fibo_2 = 2;
  let fibo_3 = 0;
  while (true) {
    if (fibo_3 > 4000000) break;
    fibo_3 = fibo_1 + fibo_2;
    if (fibo_3 % 2 === 0) {
      sum += fibo_3;
    }
    fibo_1 = fibo_2;
    fibo_2 = fibo_3;
  }
  return sum;
}

/**
가장 큰 소인수 구하기

어떤 수를 소수의 곱으로만 나타내는 것을 소인수분해라 하고, 이 소수들을 그 수의 소인수라고 합니다.

예를 들면 13195의 소인수는 5, 7, 13, 29 입니다.

600851475143의 소인수 중에서 가장 큰 수를 구하세요.

풀이

소수는 1을 제외한 약수로 1과 자기 자신만을 갖는 수를 의미.
초기 값과 i로 나누어 떨어질 경우 해당값을 저장 후
초기 값을 나누어진 값으로 변환.
위의 과정을 계속 진행 후 for문이 끝나게 되면 가장 큰 수가 저장되어 있기 때문에
결과 도출
 */
function problem3(arg) {
  let sum = 0;
  for (let i = 3; i <= arg; i++) {
    if (arg % i === 0) {
      sum = i;
      arg /= i;
    }
  }
  return sum;
}

/**
세자리 수를 곱해 만들 수 있는 가장 큰 대칭수
앞에서부터 읽을 때나 뒤에서부터 읽을 때나 모양이 같은 수를 대칭수(palindrome)라고 부릅니다.
두 자리 수를 곱해 만들 수 있는 대칭수 중 가장 큰 수는 9009 (= 91 × 99) 입니다.
세 자리 수를 곱해 만들 수 있는 가장 큰 대칭수는 얼마입니까?

풀이
1. 대칭수 중 가장 큰 숫자를 찾아야함
2. 따라서 999 * 999 부터 감소하며 찾아가는게 제일 빠름
3. 대칭수는 reverse를 사용하여 생성후 비교
4. 처음 비교시 일치하는 결과를 최종 리턴 변수에 할당
5. 반복문이 돌면서 일치하는 값이 계속 발생함
6. 이러한 일치값을 최종 변수와 비교하고, 비교 시 최종 값 보다 작게되면 할당 X
 */
function problem4() {
  let sum = 0;
  let reverseSum;
  let maxSum = 0;
  for (let i = 999; i > 100; i--) {
    for (let j = 999; j > 100; j--) {
      sum = i * j;
      reverseSum = sum.toString().split("").reverse("").join("");
      if (sum.toString() === reverseSum && sum > maxSum) {
        maxSum = sum;
      }
    }
  }
  return maxSum;
}

/**
 * 1 ~ 20 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수
 * 1 ~ 10 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 2520입니다.
 * 그러면 1 ~ 20 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 얼마입니까?
 *
 * 풀이
 * 단순히 초기 값을 1로 정해 논 후에 숫자를 차례로 늘려가며 1~20까지 숫자로 나눔.
 * 1~20까지 숫자로 나눠질때 마다 cnt++시키고 전부 다 나눠 진 숫자는 cnt가 20이므로 반복문을 중단시키고 결과 반환.
 * 20이하일 경우 cnt를 초기화 시키고 다시 실행하는 방식으로 진행
 * 시간이 굉장히 오래걸림
 * TODO: 리팻토링 해보자
 */
function problem5(arg) {
  let num = 1;
  let cnt = 0;
  while (true) {
    num++;
    for (let i = 1; i <= 20; i++) {
      if (num % i === 0) {
        cnt++;
      }
    }
    if (cnt === 20) {
      break;
    } else {
      cnt = 0;
    }
  }
  return num;
}

/**
1부터 100까지 "제곱의 합"과 "합의 제곱"의 차는?

1부터 10까지 자연수를 각각 제곱해 더하면 다음과 같습니다 (제곱의 합).

12 + 22 + ... + 102 = 385 1부터 10을 먼저 더한 다음에 그 결과를 제곱하면 다음과 같습니다 (합의 제곱).

(1 + 2 + ... + 10)2 = 552 = 3025 따라서 1부터 10까지 자연수에 대해 "합의 제곱"과 "제곱의 합" 의 차이는 3025 - 385 = 2640 이 됩니다.

그러면 1부터 100까지 자연수에 대해 "합의 제곱"과 "제곱의 합"의 차이는 얼마입니까?

풀이

1. 반복문을 사용하여 1부터 제곱을 구한 후 합을 구함
2. 위의 과정에서 자연수의 합을 구함
3. 반복문이 끝난 후 자연수 합의 제곱을 구함
4. 합의 제곱에서 제곱의 합을 뺄셈 후 결과 리턴
 */
function problem6() {
  let SumOfSquares = 0;
  let sum = 0;
  for (let i = 1; i <= 100; i++) {
    SumOfSquares = SumOfSquares + Math.pow(i, 2);
    sum += i;
  }
  let Squaredsum = Math.pow(sum, 2);

  return Squaredsum - SumOfSquares;
}

/**
 * 10001번째의 소수
 * 
 * 소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, ... 과 같이 됩니다.

이 때 10,001번째의 소수를 구하세요.

풀이

1. 먼저 소수를 구하는 함수를 생성
2. 반복문을 통해 소수일시 cnt를 +
3. cnt가 10001가 됬을때의 판별된 소수를 결과값에 할당 후 종료
4. 결과값 리턴
 */
function problem7() {
  let cnt = 0;
  let decimal = 2;
  let result = 0;

  function isPrime(n) {
    // 1이하일 경우엔 소수가 아닙니다.
    if (n <= 1) return false;

    // 2와 3일 경우엔 소수 입니다.
    if (n === 2 || n === 3) return true;

    // 2로 나눴을 때 나머지가 0일 경우엔 소수가 아닙니다.
    // 이 말인 즉슨 짝수는 다 소수가 아닙니다.
    if (n % 2 === 0) return false;

    // 최대 n - 1까지 돌려줍니다.
    let divisor = 3;
    while (n > divisor) {
      // 무엇이라도 0으로 떨어진다면 소수가 아닙니다.
      if (n % divisor === 0) return false;

      // 짝수일 경우를 제외한 홀수일 경우를 판단
      divisor += 2;
    }

    // 모든 조건을 통과했을 경우 소수로 인정받습니다.
    return true;
  }

  while (true) {
    if (isPrime(decimal)) {
      cnt++;
      if (cnt === 10001) {
        result += decimal;
        break;
      }
    }
    decimal++;
  }
  return result;
}

/**
1000자리 수 안에서 이어지는 5개 숫자의 곱 중 최댓값은?

다음은 연속된 1000자리 수입니다 (읽기 좋게 50자리씩 잘라 놓음).

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

여기서 붉게 표시된 71112의 경우 연속한 5개 숫자 7, 1, 1, 1, 2를 모두 곱하면 14입니다. 또, 그 다음 연속한 5개 숫자 11121의 경우 1, 1, 1, 2, 1을 모두 곱하면 2입니다.

이런 식으로 맨 처음 (7 × 3 × 1 × 6 × 7 = 882) 부터 맨 끝 (6 × 3 × 4 × 5 × 0 = 0) 까지 연속한 5개 숫자의 곱을 구할 수 있습니다.

이렇게 구할 수 있는 연속한 5개 숫자의 곱 중에서 가장 큰 값은 얼마입니까?

풀이

1. 숫자롤 그대로 넣을 시 JS가 표현할 수 있는 숫자 범위를 넘어서기 때문에 문자열로 변환하여 할당
2. 해당 문자를 배열로 split하여 할당ㄷ
3. 연속한 5개의 숫자의 곱을 sum 변수에 할당 후 결과값보다 sum값이 작을 경우 할당
 */

function problem8() {
  let result = 0;
  let arg =
    "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
  let splitArg = arg.split("");
  for (let i = 0; i < splitArg.length; i++) {
    let sum =
      parseInt(splitArg[i]) *
      parseInt(splitArg[i + 1]) *
      parseInt(splitArg[i + 2]) *
      parseInt(splitArg[i + 3]) *
      parseInt(splitArg[i + 4]);
    if (result < sum) {
      result = sum;
      console.log(result);
    }
  }
  return result;
}

/**
a + b + c = 1000 이 되는 피타고라스 수

세 자연수 a, b, c 가 피타고라스 정리 a2 + b2 = c2 를 만족하면 피타고라스 수라고 부릅니다 (여기서 a < b < c ).
예를 들면 32 + 42 = 9 + 16 = 25 = 52이므로 3, 4, 5는 피타고라스 수입니다.

a + b + c = 1000 인 피타고라스 수 a, b, c는 한 가지 뿐입니다. 이 때, a × b × c 는 얼마입니까?

풀이

a의 제곱근 + b의 제곱근을 한 값을 거듭제곱한 값이 소수값이 아닌 정수일때 피타고라스의 수로 정의됨
따라서 정수로 변환한 값과 아닌 값이 일치하고 a, b, c값의 합이 1000일때
a * b * c라는 결과값을 리턴  
 */
function problem9(arg) {
  for (let a = 1; a <= arg; a++) {
    for (let b = 1; b <= arg; b++) {
      let c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
      if (c === parseInt(c) && a + b + c === arg) {
        console.log(c, a, b);
        return a * b * c;
      }
    }
  }
}

/**
 * 이백만 이하 소수의 합

10 이하의 소수를 모두 더하면 2 + 3 + 5 + 7 = 17 이 됩니다.

이백만(2,000,000) 이하 소수의 합은 얼마입니까?

풀이

초기
1. 소수를 판별하는 함수 생성
2. 이백만(2,000,000) 이하의 전체수의 소수를 판별
3. 위의 과정 중 소수로 판별된 값을 결과 값에 계속 더함
4. 결과값 리턴
5. 문제는 해결 되었으니 무려 3분이라는 연산 시간이 걸림

개선된 풀이
1. 에라토스테네스의 체를 활용하여 구현
2. 먼저 이백만(2,000,000)이하의 값을 반복문을 통하여 배열에 전부 push
3. 주어진 수의 제곱근까지만 계산해서 불필요한 반복을 최소화한다.
4. arr[i] 가 소수일 경우, 반복문을 진행한다.
5. 맨 처음 시작하는 2는 소수이므로, 2를 제외한 2의 제곱부터, 제곱 값만 체크하여 지워나감
6. 제곱근까지 반복한다.
7. 0, 1 은 소수가 아니므로 false 값으로 변경
8. filter로 false값을 걸러내고, reduce로 전체 배열의 합을 구함
 */

function problem10(arg) {
  const arr = [];

  for (let i = 0; i <= arg; i += 1) {
    arr.push(i);
  }

  for (let i = 2; i * i <= arg; i += 1) {
    if (arr[i]) {
      for (let j = i * i; j <= arg; j += i) {
        arr[j] = false;
      }
    }
  }

  arr.splice(0, 2, false, false);

  const result = arr
    .filter((value) => {
      return value !== false;
    })
    .reduce((pre, cur) => {
      return pre + cur;
    });

  return result;
}
/**
 * 20×20 격자에서 연속된 네 수의 곱 중 최댓값

아래와 같은 20×20 격자가 있습니다.

위에서 대각선 방향으로 연속된 붉은 수 네 개의 곱은 26 × 63 × 78 × 14 = 1788696 입니다.

그러면 수평, 수직, 또는 대각선 방향으로 연속된 수 네 개의 곱 중 최댓값은 얼마입니까?

풀이

1. 가로, 세로, 좌에서 우 대각선, 우에서 좌 대각선의 값을 구함
2. 4개씩 쪼개서 reduce에 넣은 후 곱셈값을 구한 후 결과 배열에 넣음
3. 최종적으로 배열안에 Max값을 찾아서 리턴
 */

function problem11(input) {
  const numtriangle = [
    [08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08],
    [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00],
    [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65],
    [52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91],
    [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
    [24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
    [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
    [67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21],
    [24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
    [21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95],
    [78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92],
    [16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57],
    [86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
    [19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40],
    [04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
    [88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
    [04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36],
    [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16],
    [20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54],
    [01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48],
  ];
  // input만큼의 곱셉을 담을 배열
  const multipletriangle = [];

  // 배열의 인자들을 곱할 함수
  const multiple = (arr) =>
    arr.reduce((p, c) => {
      return p * c;
    });

  // 반복문을 두개를 돌려 2차원 배열들의 모든 인자들을 접근할 수 있다.
  for (let i = 0; i <= 20 - input; i++) {
    for (let j = 0; j <= 20 - input; j++) {
      // 가로방향
      multipletriangle.push(multiple(numtriangle[i].slice(j, j + input)));

      // 세로방향
      multipletriangle.push(
        multiple(
          ((triangle) => {
            for (let k = 0; k < input; k++) {
              triangle.push(numtriangle[i + k][j]);
            }
            // console.log(triangle)
            return triangle;
          })([])
        )
      );

      // 좌에서 우로 향하는 대각선
      multipletriangle.push(
        multiple(
          ((triangle) => {
            for (let k = 0; k < input; k++) {
              triangle.push(numtriangle[i + k][j + k]);
            }
            return triangle;
          })([])
        )
      );

      // 우에서 좌로 향하는 대각선
      multipletriangle.push(
        multiple(
          ((triangle) => {
            for (let k = 0; k < input; k++) {
              triangle.push(numtriangle[i + k][j + (input - 1) - k]);
            }
            return triangle;
          })([])
        )
      );
    }
  }
  // 최대값 찾기
  return multipletriangle.reduce((prev, cur) => Math.max(prev, cur));
}

/**
500개 이상의 약수를 갖는 가장 작은 삼각수는?

1부터 n까지의 자연수를 차례로 더하여 구해진 값을 삼각수라고 합니다.
예를 들어 7번째 삼각수는 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28이 됩니다.
이런 식으로 삼각수를 구해 나가면 다음과 같습니다.

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
이 삼각수들의 약수를 구해 봅시다.

1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
위에서 보듯이, 5개 이상의 약수를 갖는 첫번째 삼각수는 28입니다.

그러면 500개 이상의 약수를 갖는 가장 작은 삼각수는 얼마입니까?

풀이

초기 풀이
1. 단순히 값을 계속 올려서 약수의 갯수가 500개인 수를 찾으려고 함
2. 시간이 너무 오래 걸리고 도저히 끝나지 않아 다른 방법 물색

최종 풀이
1. 삼각수 공식 N = n * (n+1) / 2을(시그마 공식) 활용하여 해결
2. 약수 개수 구하는 건 속도를 위해서 대상의 루트까지 루프
3. 모든 숫자의 약수는 자기 자신의 절반을 넘지 못함
4. 따라서 sqrt(제곱근)을 사용하여 시간을 줄였음.
 */
function problem12() {
  // let value = 1;
  // let sum = 0;
  // function divisors(integer) {
  //   let arr = [];
  //   for (let i = 1; i <= integer; i++) {
  //     if (integer % i == 0) {
  //       arr.push(i);
  //     }
  //   }
  //   return arr;
  // }
  // while (true) {
  //   sum += value;
  //   let result = divisors(sum);
  //   console.log(result)
  //   if (result.length >= 500) {
  //     break;
  //   }
  //   value++;
  // }
  // return sum;

  let n, sum, cnt;
  n = 1;

  function cnt_div(n) {
    let cnt;
    let max_length;

    cnt = 0;
    max_length = Math.sqrt(n);

    for (let i = 0; i < max_length; i++) {
      if (n % i === 0) {
        cnt += 2;
      }
    }
    if (max_length * max_length === n) {
      cnt -= 1;
    }
    return cnt;
  }

  while (true) {
    sum = (n * (n + 1)) / 2;
    cnt = cnt_div(sum);
    if (cnt >= 500) {
      return sum;
    }
    n++;
  }
}

/**
50자리 수 100개를 더한 값의 첫 10자리 구하기

아래에 50자리 수가 100개 있습니다. 이것을 모두 더한 값의 첫 10자리는 얼마입니까?

풀이

1. 각 50자리 수를 배열에 할당
2. 숫자의 앞자리 12자리만 더해도 결과적으로 첫 10자리의 값은 같음
3. 따라서 숫자르 문자열로 변환 후 12자리만 덧셈
4. 숫자로 변환 후 결과 리턴
 */
function problem13() {
  let n = [
    "37107287533902102798797998220837590246510135740250",
    "46376937677490009712648124896970078050417018260538",
    "74324986199524741059474233309513058123726617309629",
    "91942213363574161572522430563301811072406154908250",
    "23067588207539346171171980310421047513778063246676",
    "89261670696623633820136378418383684178734361726757",
    "28112879812849979408065481931592621691275889832738",
    "44274228917432520321923589422876796487670272189318",
    "47451445736001306439091167216856844588711603153276",
    "70386486105843025439939619828917593665686757934951",
    "62176457141856560629502157223196586755079324193331",
    "64906352462741904929101432445813822663347944758178",
    "92575867718337217661963751590579239728245598838407",
    "58203565325359399008402633568948830189458628227828",
    "80181199384826282014278194139940567587151170094390",
    "35398664372827112653829987240784473053190104293586",
    "86515506006295864861532075273371959191420517255829",
    "71693888707715466499115593487603532921714970056938",
    "54370070576826684624621495650076471787294438377604",
    "53282654108756828443191190634694037855217779295145",
    "36123272525000296071075082563815656710885258350721",
    "45876576172410976447339110607218265236877223636045",
    "17423706905851860660448207621209813287860733969412",
    "81142660418086830619328460811191061556940512689692",
    "51934325451728388641918047049293215058642563049483",
    "62467221648435076201727918039944693004732956340691",
    "15732444386908125794514089057706229429197107928209",
    "55037687525678773091862540744969844508330393682126",
    "18336384825330154686196124348767681297534375946515",
    "80386287592878490201521685554828717201219257766954",
    "78182833757993103614740356856449095527097864797581",
    "16726320100436897842553539920931837441497806860984",
    "48403098129077791799088218795327364475675590848030",
    "87086987551392711854517078544161852424320693150332",
    "59959406895756536782107074926966537676326235447210",
    "69793950679652694742597709739166693763042633987085",
    "41052684708299085211399427365734116182760315001271",
    "65378607361501080857009149939512557028198746004375",
    "35829035317434717326932123578154982629742552737307",
    "94953759765105305946966067683156574377167401875275",
    "88902802571733229619176668713819931811048770190271",
    "25267680276078003013678680992525463401061632866526",
    "36270218540497705585629946580636237993140746255962",
    "24074486908231174977792365466257246923322810917141",
    "91430288197103288597806669760892938638285025333403",
    "34413065578016127815921815005561868836468420090470",
    "23053081172816430487623791969842487255036638784583",
    "11487696932154902810424020138335124462181441773470",
    "63783299490636259666498587618221225225512486764533",
    "67720186971698544312419572409913959008952310058822",
    "95548255300263520781532296796249481641953868218774",
    "76085327132285723110424803456124867697064507995236",
    "37774242535411291684276865538926205024910326572967",
    "23701913275725675285653248258265463092207058596522",
    "29798860272258331913126375147341994889534765745501",
    "18495701454879288984856827726077713721403798879715",
    "38298203783031473527721580348144513491373226651381",
    "34829543829199918180278916522431027392251122869539",
    "40957953066405232632538044100059654939159879593635",
    "29746152185502371307642255121183693803580388584903",
    "41698116222072977186158236678424689157993532961922",
    "62467957194401269043877107275048102390895523597457",
    "23189706772547915061505504953922979530901129967519",
    "86188088225875314529584099251203829009407770775672",
    "11306739708304724483816533873502340845647058077308",
    "82959174767140363198008187129011875491310547126581",
    "97623331044818386269515456334926366572897563400500",
    "42846280183517070527831839425882145521227251250327",
    "55121603546981200581762165212827652751691296897789",
    "32238195734329339946437501907836945765883352399886",
    "75506164965184775180738168837861091527357929701337",
    "62177842752192623401942399639168044983993173312731",
    "32924185707147349566916674687634660915035914677504",
    "99518671430235219628894890102423325116913619626622",
    "73267460800591547471830798392868535206946944540724",
    "76841822524674417161514036427982273348055556214818",
    "97142617910342598647204516893989422179826088076852",
    "87783646182799346313767754307809363333018982642090",
    "10848802521674670883215120185883543223812876952786",
    "71329612474782464538636993009049310363619763878039",
    "62184073572399794223406235393808339651327408011116",
    "66627891981488087797941876876144230030984490851411",
    "60661826293682836764744779239180335110989069790714",
    "85786944089552990653640447425576083659976645795096",
    "66024396409905389607120198219976047599490197230297",
    "64913982680032973156037120041377903785566085089252",
    "16730939319872750275468906903707539413042652315011",
    "94809377245048795150954100921645863754710598436791",
    "78639167021187492431995700641917969777599028300699",
    "15368713711936614952811305876380278410754449733078",
    "40789923115535562561142322423255033685442488917353",
    "44889911501440648020369068063960672322193204149535",
    "41503128880339536053299340368006977710650566631954",
    "81234880673210146739058568557934581403627822703280",
    "82616570773948327592232845941706525094512325230608",
    "22918802058777319719839450180888072429661980811197",
    "77158542502016545090413245809786882778948721859617",
    "72107838435069186155435662884062257473692284509516",
    "20849603980134001723930671666823555245252804609722",
    "53503534226472524250874054075591789781264330331690",
  ];
  let sum = 0;
  for (let ele of n) {
    console.log(ele.substring(0, 12));
    sum += parseInt(ele.substring(0, 12));
  }
  return sum;
}

/**
백만 이하로 시작하는 우박수 중 가장 긴 과정을 거치는 것은?

양의 정수 n에 대하여, 다음과 같은 계산 과정을 반복하기로 합니다.

n → n / 2 (n이 짝수일 때)
n → 3 n + 1 (n이 홀수일 때)

13에 대하여 위의 규칙을 적용해보면 아래처럼 10번의 과정을 통해 1이 됩니다.

13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
아직 증명은 되지 않았지만, 이런 과정을 거치면 어떤 수로 시작해도 마지막에는 1로 끝나리라 생각됩니다.
(역주: 이것은 콜라츠 추측 Collatz Conjecture이라고 하며, 이런 수들을 우박수 hailstone sequence라 부르기도 합니다)

그러면, 백만(1,000,000) 이하의 수로 시작했을 때 1까지 도달하는데 가장 긴 과정을 거치는 수는 얼마입니까?

참고: 계산 과정에는 백만을 넘어가는 수가 나와도 괜찮습니다.

풀이

1. 우박수를 구하는 함수 생성
1-1. 반복문을 통해 콜라츠 추측 로적 구현
1-2. 반복시마다 cnt 증가 후 1이 됬을때 cnt 리턴
2. 백만 이하의 수를 우박수 함수로 전체 탐색(브루트 포스 방식)
3. 조건에 맞는 최종 결과 리턴
 */

function problem14(arg) {
  let cnt = 0;
  let max = 0;
  let ans = 0;
  // 우박수 검사 함수
  function hail(n) {
    let cnt = 0;
    while (n !== 1) {
      cnt++;
      n % 2 === 0 ? (n = n / 2) : (n = n * 3 + 1);
    }
    return cnt;
  }

  for (let i = 1; i <= arg; i++) {
    cnt = hail(i);
    if (max < cnt) {
      max = cnt;
      ans = i;
    }
    cnt = 0;
  }
  return ans;
}

/**
20×20 격자의 좌상단에서 우하단으로 가는 경로의 수

그러면 20 × 20 격자에는 모두 몇 개의 경로가 있습니까?

풀이

1. 중복집합순열을 공식을 통해 풀이 가능
2. 순열(順列, permutation)은 서로 다른 n 개의 원소 중에서 r 개()를 뽑아서 한 줄로 세우는 경우의 수이다.
 */
function problem15() {
  const factorial = (n) => (n === 1 ? 1 : n * factorial(n - 1));
  return factorial(40) / (factorial(20) * factorial(20));
}
/**
2^1000 의 각 자릿수를 모두 더하면 ?

215 = 32768 의 각 자릿수를 더하면 3 + 2 + 7 + 6 + 8 = 26 입니다.

21000 의 각 자릿수를 모두 더하면 얼마입니까 ?

풀이
1. 2^1000의 값은 정수의 표현 범위를 벗어남
2. 따라서 각 자리수를 배열의 한 요소로 저장해야함
3. 초기 1값부터 2의 제곱 값을 배열의 첫 요소로 할당
4. 해당 과정에서 10이상의 값이 나올 시, 해당 자리수의 배열 자리에 추가하기 위해 - 10을 진행
4-1. 위의 과정 진행 시 각 자리수 별로 10이상의 값이 나올 시 다음 자리수의 배열 자리에 값 할당
5. 최종 배열의 자리에 할당되어있는 값을 반복문을 통하여 합 도출
6. 결과 리턴
*/
function problem16(pow) {
  let befNum = [1];
  let aftNum = new Array();
  let temNum;
  let odFlag = false;
  for (let i = 1; i <= pow; i++) {
    aftNum = [];
    for (let j = befNum.length - 1; j >= 0; j--) {
      temNum = befNum[j];
      temNum = temNum * 2;
      if (odFlag == true) {
        temNum += 1;
        odFlag = false;
      }
      if (temNum < 10) {
        aftNum.unshift(temNum);
        odFlag = false;
      } else {
        aftNum.unshift(temNum - 10);
        if (j == 0) aftNum.unshift(1);
        else odFlag = true;
      }
    }
    befNum = aftNum;
  }
  temNum = 0;
  temNum = befNum.reduce((pre, cur) => Number(pre) + Number(cur));
  return temNum;
}

/**
1부터 1000까지 영어로 썼을 때 사용된 글자의 개수는?

1부터 5까지의 수를 영어로 쓰면 one, two, three, four, five 이고,
각 단어의 길이를 더하면 3 + 3 + 5 + 4 + 4 = 19 이므로 사용된 글자는 모두 19개입니다.

1부터 1,000까지 영어로 썼을 때는 모두 몇 개의 글자를 사용해야 할까요?

참고: 빈 칸이나 하이픈('-')은 셈에서 제외하며, 단어 사이의 and 는 셈에 넣습니다.
  예를 들어 342를 영어로 쓰면 three hundred and forty-two 가 되어서 23 글자,
  115 = one hundred and fifteen 의 경우에는 20 글자가 됩니다.

풀이

1. 1 ~ 19까지의 숫자를 나타내는 문자열을 객체로 저장
1-1. 10 단위의 숫자를 나타내는 문자열도 객체로 저장
2. 초기 100 이하의 숫자들의 사용된 글자수를 저장
2-2. 그 후 10을 곱셈 -> 100단위의 숫자의 앞글자 (ex. 100 -> onehundredand, 200 -> twohundredand)
형식으로 만들고 뒤에 붙는 숫자는 어차피 같기 때문에 반복문 없이 *10을 함
3. 100단위 숫자 갯수 저장
3-3. 그 후 100을 곱셈 ->  100, 101, 102, 103, 104... 이런식으로 가게 되면 결국 100단위 숫자의 반복횟수는 총 100번
4. 천단위 숫자는 하나이기 때문에 단순 길이 계산
5. 그 후 구한 수 모두 덧셈.
5-1. 곱셈과정에서 9를 뺀 이유는 100 -> one hundred인데 and가 붙은 수가 총 9개가 있기 때문
 */

function problem17() {
  let mapOfOne = {
    '0': '',
    '1': 'one',
    '2': 'two',
    '3': 'three',
    '4': 'four',
    '5': 'five',
    '6': 'six',
    '7': 'seven',
    '8': 'eight',
    '9': 'nine',
    '10': 'ten',
    '11': 'eleven',
    '12': 'twelve',
    '13': 'thirteen',
    '14': 'fourteen',
    '15': 'fifteen',
    '16': 'sixteen',
    '17': 'seventeen',
    '18': 'eighteen',
    '19': 'nineteen'
  };

  let mapOfTen = {
    '1': 'teen',
    '2': 'twenty',
    '3': 'thirth',
    '4': 'forty',
    '5': 'fifty',
    '6': 'sixty',
    '7': 'seventy',
    '8': 'eighty',
    '9': 'ninety'
  };

  let sumOfOne = 0;

  for (let i = 1; i < 100; i++) {
    if(i <= 19) {
      sumOfOne += mapOfOne[String(i)].length;
    } else {
      sumOfOne += mapOfTen[String(i).substr(0, 1)].length + mapOfOne[String(i).substr(1, 1)].length;
    }
  }
  sumOfOne *= 10;

  let sumOfTen = 0;
  let hundred = 'hundredand';

  for (let j = 1; j < 10; j++) {
    sumOfTen += (mapOfOne[String(j)].length + hundred.length);
  }
  sumOfTen *= 100;

  let thousand = 'onethousand';
  let answer = sumOfOne + sumOfTen - ('and'.length * 9) + thousand.length;
  return answer;
}

/**
삼각형을 따라 내려가면서 합이 최대가 되는 경로 찾기

삼각형의 꼭대기부터 아래쪽으로 인접한 수를 찾아 내려가면서 합을 구하면, 위의 그림처럼 3 + 7 + 4 + 9 = 23 이 가장 큰 합을 갖는 경로가 됩니다.

다음 삼각형에서 합이 최대가 되는 경로를 찾아서 그 합을 구하세요.

풀이

1. 2차원 배열에 값을 할당
2. 아래에서부터 위로 올라가면서 가능한 경로의 최대합을 유지
3. 먼저 제일 아래줄의 숫자 배열 부터 시작
4. 왼쪽 제일 첫쨰 수와 오른쪽 수를 비교하여 더 큰 숫자를 윗줄의 값과 더해줌
5. 4번의 과정을 반복하다보면 맨 윗줄의 값을 최종적으로 처리하게 되며 이 값이 가장 큰 값으로 만들어 짐
 */

function problem18() {
  let triangle = [
    [75],
    [95, 64],
    [17, 47, 82],
    [18, 35, 87, 10],
    [20, 04, 82, 47, 65],
    [19, 01, 23, 75, 03, 34],
    [88, 02, 77, 73, 07, 63, 67],
    [99, 65, 04, 28, 06, 16, 70, 92],
    [41, 41, 26, 56, 83, 40, 80, 70, 33],
    [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
    [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
    [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
    [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
    [63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
    [04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23]
  ];
  for (let i = 14; i >= 0; i--) {
    for (let j = 0; j < i; j++) {
      if (triangle[i][j] > triangle[i][j + 1]) {
        triangle[i - 1][j] += triangle[i][j]
      } else {
        triangle[i - 1][j] += triangle[i][j + 1]
      }
    }
  }
  return triangle[0][0];
}

/**
20세기에서, 매월 1일이 일요일인 경우는 몇 번?

다음은 달력에 관한 몇 가지 일반적인 정보입니다 (필요한 경우 좀 더 연구를 해 보셔도 좋습니다).

1900년 1월 1일은 월요일이다.
4월, 6월, 9월, 11월은 30일까지 있고, 1월, 3월, 5월, 7월, 8월, 10월, 12월은 31일까지 있다.
2월은 28일이지만, 윤년에는 29일까지 있다.
윤년은 연도를 4로 나누어 떨어지는 해를 말한다. 하지만 400으로 나누어 떨어지지 않는 매 100년째는 윤년이 아니며, 400으로 나누어 떨어지면 윤년이다
20세기 (1901년 1월 1일 ~ 2000년 12월 31일) 에서, 매월 1일이 일요일인 경우는 총 몇 번입니까?

풀이

1. Date.UTC를 활용하여 1901년 부터 2000년까지 각 월의 1일이 일요일인 경우 cnt++.
2. 2001년이 되는 순간 그도안 누적되었던 cnt 반환.
 */
function problem19() {
  let cnt = 0;
  for (let i = 1; ; i++) {
    for (let j = 1; ; j++) {
      let utcDate = new Date(Date.UTC(i, j));
      const dateArr = utcDate.toString().split(" ")
      if (dateArr[0] === 'Sun' && dateArr[2] === '01') {
        cnt++;
      }
      if (dateArr[3] === '2001') {
        return cnt;
      }
    }
  }
}

/**
100! 의 자릿수를 모두 더하면?

n! 이라는 표기법은 n × (n − 1) × ... × 3 × 2 × 1을 뜻합니다.

예를 들자면 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800 이 되는데,
여기서 10!의 각 자릿수를 더해 보면 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 입니다.

100! 의 자릿수를 모두 더하면 얼마입니까?

풀이

1. factorial 함수를 사용하되 BigInt를 사용하여 정수 표현 범위 이상의 숫자를 사용하게 하게 적용
2. 출력된 결과를 문자열로 변환
3. 변환된 문자열을 배열로 변환
4. 변환된 문자열 배열을 reduce를 사용하여 element에 하나씩 접근
5. parseInt로 숫자형으로 변환 후 덧셈 실시
6. 결과 리턴
 */
function problem20(arg) {
  function factorial(n) {
    let result = BigInt(1);
    for(let i=2; i<=n; i++) result *= BigInt(i);
    return result;
}
  const facToString = factorial(arg).toString().split("").reduce((pre, cur) => parseInt(pre) + parseInt(cur))
  return facToString;
}

/**
10000 이하 모든 친화수(우애수)의 합은?

n의 약수들 중에서 자신을 제외한 것의 합을 d(n)으로 정의했을 때,
서로 다른 두 정수 a, b에 대하여 d(a) = b 이고 d(b) = a 이면
a, b는 친화쌍이라 하고 a와 b를 각각 친화수(우애수)라고 합니다.

예를 들어 220의 약수는 자신을 제외하면 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110 이므로 그 합은 d(220) = 284 입니다.
또 284의 약수는 자신을 제외하면 1, 2, 4, 71, 142 이므로 d(284) = 220 입니다.
따라서 220과 284는 친화쌍이 됩니다.

10000 이하의 친화수들을 모두 찾아서 그 합을 구하세요.

풀이

1. 약수의 합을 구하는 함수 생성
2. 우애수를 구하는 조건에 맞춰 함수 실행
 */

function problem21() {
  let result = 0;
  function divisorSum(arg) {
    let sum = 0;
    for (let i = 1; i < arg; i++) {
      if (arg % i === 0) {
        sum += i;
      }
    }
    return sum;
  }
  for (let b = 1; b <= 10000; b++) {
    let a = divisorSum(b)
    if (b === divisorSum(a) && a !== b) {
      result += b;
    }
  }
  return result;
}

function problem22() {
  const txt = fs.readFileSync("name.txt");
  const alphabet = {
    "A": 1,
    "B": 2,
    "C": 3,
    "D": 4,
    "E": 5,
    "F": 6,
    "G": 7,
    "H": 8,
    "I": 9,
    "J": 10,
    "K": 11,
    "L": 12,
    "M": 13,
    "N": 14,
    "O": 15,
    "P": 16,
    "Q": 17,
    "R": 18,
    "S": 19,
    "T": 20,
    "U": 21,
    "V": 22,
    "W": 23,
    "X": 24,
    "Y": 25,
    "Z": 26,
  }
  nameArr = txt.toString().split(',').sort();
  let result = 0;
  let sum = 0;
  for (let i = 0; i < nameArr.length; i++) {
    splitName = nameArr[i].split('"')[1].split('');
    for (let ele of splitName) {
      sum += alphabet[ele];
    }
    result += (sum * i);
  }
  return result;
}

let startTime = new Date().getTime();

// const result = problem2(4000000);
// const result = problem3(600851475143);
// const result = problem4();
// const result = problem5(1000);
// const result = problem6();
// const result = problem7();
// const result = problem8();
// const result = problem9(1000);
// const result = problem10(2000000);
// const result = problem11(4);
// const result = problem12();
// const result = problem13();
// const result = problem14(1000000);
// const result = problem15();
// const result = problem16(1000);
// const result = problem17();
// const result = problem18();
// const result = problem19();
// const result = problem20(100);
// const result = problem21();
const result = problem22();

let elapsed = new Date().getTime() - startTime;
console.log("타임 :", elapsed / 1000); // 1000ms -> 1sec

console.log("결과: ", result);
